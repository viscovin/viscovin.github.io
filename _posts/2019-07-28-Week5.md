---
layout: post
title: Week 5
---
# Windows Internals
## Memory Manipulation 
### Rootkits 
- Malware that actively conceals its existence and actions from users and system processes.
- Approximately 10% of current malware use rootkit
- Rootkits are most prevalent in 32 bit Windows
- Handful of families so far for 64 bit
- Rootkits are one of the best way to learn about kernel security challenges.

**Challenges once malicious code enters kernel**
- Harder for rootkits to enter 64 bit kernel
- Rootkits can infiltrate 64 bit OS Kernel by

  a) Bypassing driver signing check (e.g. using testsigning mode)
  
  b) Modifying the windows boot path (MBR etc) – Secure boot prevents this.
  
  c) Kernel exploits in Windows kernel  or third party drivers.
  
  d) Stealing valid digisigs (Similar to Stuxnet)

**Kernal Memory**
- Is a flat memory model with no security separation. 
- Any kernel driver can access any part of memory. 
- Composed of windows kernel (ntoskrnl.exe) as well as driver code. 
- Many important structures that are prime targets for stealth. SSDT, IRP, IDT etc. 
- Windbg commands: .process command, lm, !devobj, !drvobj, !devstack, !irp etc. Virtual to physical memory etc.

### Lab: Rootkit Agony Analysis
**Instructions** 
- Extract and copy file from C:\Users\Admin\Desktop\malware\WindowsInternals\Agony.zip  to \Desktop\bad (no extension)
- Run FakeNet
- Run Cuckoo

<img src= "https://raw.githubusercontent.com/viscovin/viscovin.github.io/master/images/agony1.JPG">

Files found in Cuckoo where:
- bad.bin
- tzres.dll.bin
- tzres.dll.mui.bin
- sortdefault.nls.bin

After running Tuluka and dir \*.sys on CMD we see hidden file created "wininit.sys"

<img src= "https://raw.githubusercontent.com/viscovin/viscovin.github.io/master/images/agony2.JPG">

We then opened livekd and unassemble the code in addresses shown in the Tuluka app
u 82c70ebf for the actual NtEnumerateValueKey 
u 97143480 for what is there now after running "bad"

<img src= "https://raw.githubusercontent.com/viscovin/viscovin.github.io/master/images/agony3.jpg">

Using livekd we use command **dps n!KiServiceTable L191** shows the list of the systems API's with three columns 
- Address Pointer
- Address of Code 
- Name of API

Scrolling through this list we can find anomalies 

<img src= "https://raw.githubusercontent.com/viscovin/viscovin.github.io/master/images/agony4.jpg">

### Thread
Thread is the smallest ‘unit’ of execution that can execute code.

**Important concepts of a thread**
- Thread Context: stores all the related register values of the thread. During execution register values are stored in CPU , else they are in Memory.  KD> DT _CONTEXT
- Thread Stack: Each Thread has its own stack.   Data is copied for security.
   * User mode stack. Used for thread’s function calls and local variables. 
   * Kernel Stack. Used when control is transferred from user to kernel. 
- Thread Environment Block (TEB): TEB contains threat specific information like Exception handling and TLS. KD> DT _TEB
- Thread Scheduling
- Thread – Process relationship

**Thread Object defines a thread**
- Kernel Object are data structure defined by OS to describe various OS constructs, thread being one such construct.
- TEB, ThreatStack, Context, Priority, State etc are all defined within this struct.

**NOTE:** Windbg command to see thread object : KD> dt_KTHREAD

Thread context 


TEB : 


